#################################################################################################
#                                                                                               #
#   CTools编译器                                                                                   #
#   AderStep工作组2013-2014                                                                        #
#   Autor：GatieMe                                                                               #
#   Copyright   HRBU~2013-2014                                                                  #
#                                                                                               #
#################################################################################################
#
#
#
[代码修改信息]0.6
@@   修复了douTuple头结点未分配空间就使用所造成的BUG[2013/3/21-15:39]
@@   修复了判断为分界符[5]不可打印字符的输出造成的程序错误isprint()
##   采用较低级的办法处理了二元组结点域中char *m_value指针的赋值问题, 暂时修改为char m_value[20];
#
#
#
[代码修改信息]0.7
@@   添加主函数传参的处理信息
@@   增加了TupleNode结点的属性m_fileInfo, 替换了原来的[int]m_keycode, 作为HEAD结点的数据域
     [int] m_keycount用来存储当前文件的词法信息数目
     [char*] m_file用来存储当前编译的文件的文件名
#
#
#
[代码修改信息]0.8
@@  添加双缓冲区的设置, 将文件中的信息读取到缓冲区以提高效率[未完成]
#
#
#
[代码修改信息]0.9
@@  修改双缓冲区的设置, 将文件中的信息读取到缓冲区以提高效率[未完成]
@@  添加符号表SymbolTable的信息, 将标识符插入到符号表中的哈希表中
#
#
#
[代码修改信息]0.95
@@  修改双缓冲区的设置, 将文件中的信息读取到缓冲区以提高效率[未完成]
@@  修改符号表SymbolTable的信息, 将标识符插入到符号表中的哈希表中
@@  更改函数BufferLexical将大于100行的函数全部分成几个分别处理的函数
    分别处理串[关键字或者标识符], 以及处理运算符, 分界面符号
#
#
#
[代码修改信息]0.96
@@  修改符号表SymbolTable的信息, 将标识符插入到符号表中的哈希表中
@@  更改函数BufferLexical将大于100行的函数全部分成几个分别处理的函数
    分别处理串[关键字或者标识符], 以及处理运算符, 分界面符号
@@  将所有的参数更改为指针类型, 更改缓冲区的设置, 缓冲区改为堆空间申请开辟
#
#
#
[代码修改信息]0.97
@@  更新所有的程序结构，消除所有的警告信息
    将PUBLIC函数声明移动到.h文件, 将PRIVATE函数声明移动到.c文件中
    结构体命名的更新， 消除指针转型的警告信息
@@  修改一个逻辑问题:
    CopyToken函数取出的是[m_lexme, m_forward)之间的字符串
    TokenLength = m_forward - m_lexeme;
    CheckLexemeToForward{  m_lexeme = m_forward; }
    但是跳过' ', '\n', '\r', '\t'的时候会出现一个问题，就是开始指针指向了一个分界面符号，
    因此在跳过这些符号的时候应该特别处理,
    跳过的过程可能出现在，遇到分界面循环跳过时, 处理//注释跳过直到'\n‘时
@@  也可以这样修改
    CopyToken函数取出的是(m_lexme, m_forward)之间的字符串
    TokenLength = m_forward - m_lexeme - 1;
    CheckLexemeToForward{  m_lexeme = m_forward + 1; }
    但是跳过' ', '\n', '\r', '\t'的时候会出现一个问题，就是开始指针指向了一个分界面符号，
    因此在跳过这些符号的时候应该特别处理,
    跳过的过程可能出现在，遇到分界面循环跳过时, 处理//注释跳过直到'\n‘时
#
#
#
#
[代码修改信息]0.98
@@  进一步减少BufferLexical函数的长度,
    信息插入过程在DisSeparator和DisOperator函数中实现
@@  修改了几个逻辑错误
    1-=>在Scanner()中, 在将字符串取出来以后加入了判断当前标识符是否结束的判断
    只要当前字符是字母, 数字, 或者_说明当前串下一个字符仍然是当前串的一部分
    那么直接返回NULL, 去取出来下一个字符， 知道整个字符串结束
    另外一中可能性就是出现if和ifdef的前缀字符的判断
    2-=>CopyToken()函数中如果当前串长度小于1, 直接返回,
#
#
#
[代码修改信息]0.99
@@  修改了符号表SymbolTable的定义为Identifier**, 并对其部分函数进行休息
@@  增加了常量表的定义和函数实现, 但是常量表采用伪哈希表定义方式实现
@@  修复了文件以换行, 空格等控制字符结束后的程序异常终止并且无法识别EOF的BUG
@@  修改了词法符号的输出格式和输出信息
#
#
#
[代码修改信息]0.1.0
@@  【【重大更新】】取消符号表的构建信息, 而转为直接将文件信息存入符号表中
@@  发现漏洞, 词法分析器无法识别char* str, 但是可以识别char *str;
@@  修改了文件的包含结构,
    在配置文件Config.h中添加主要头文件包含, 其他头文件只要包含直接或者间接包含Config.h即可
    在Config.h中添加主要的调试宏信息CTOOLS_DEBUG_DEFINE和信息提示宏CTOOLS_SHOWS_DEFINE
    在Config.h中添加主要信息输出宏函数FUNCTION( ), LINE( ), FILENAME( );
#
#
#
[代码修改信息]0.1.1
@@  修改了BufferTuple.h文件中TupleNode结构体的定义,
    原本当结点是头结点时, 用一个特殊的结构体来存储文件信息和词法信息数目,
    现在改为直接用m_kind域来存储当前的文件词法信息, 而用联合体中char*来存储文件名，
    每个结点省去了一个字长(void *)的空间
    这样做的好处是, 整个词法信息中只有头结点存储需要存储HEAD信息, 这样原来的存储结构,
    相当于后面的词法结构每个都有一个机器字长的空间是浪费的。。
@@  优化了Scanner函数的实现,
    将当恰恰能字符信息的判断放在了取出字符的前面, 防止了内存泄漏
    将释放token空间的代码放在了函数返回之前, 减少了代码冗余。
#
#
#
[代码修改信息]0.1.2
@@  修复了重要BUG， 为(char *)token指向字符串开始开辟空间时,
    应该使用(strlen(tolken) + sizeof(char))
    但是使用了sizeof(token)并不是测量的是字符串长度, 而是测量的是token所属类型(char *)所占空间也就是4KB
#
#
#
[代码修改信息]0.1.3
@@  增加了对字符串常量的处理
    对应的函数Lexxical.c -=>  DisString(...);
#
#
#
[代码修改信息]0.1.4
@@  修改了将词法信息插入的时候的处理,
    减少了额外的堆空间开辟, 而是改为将取出来的字符串地址直接赋值给词法结点的指针域
    InsertTupleId, InsertTupleLiteral
#
#
#
[代码修改信息]0.1.5
@@  修改了词法信息插入过程中有的信息没有插入的的BUG
@@  修改了在处理分界符和字符串的时候, 词法信息数目增加数目不一致的情况
@@  修复了双缓冲区初始化过程中的BUG,
    Lexical.h中  -=>  DouBuffer *douBuffer = malloc(sizeof(douBuffer));
         修改为  -=>  DouBuffer *douBuffer = malloc(sizeof(DouBuffer));
@@  在配置文件Cinfig中增加了HRLP的宏定义信息
    现在配置文件中的三个宏的主要作用如下
    CTOOLS_DEBUG_DEFINE -=> 用来开启调试输出信息
    CTOOLS_HELPS_DEFINE -=> 用来开启帮助信息,　主要用来提示一些数据的初始化, 数据写入读出的信息
    CTOOLS_SHOWS_DEFINE —=> 用来开启打印收集到的词法信息
#
#
#
[代码修改信息]0.1.6
@@  声明BinaryTuple.h文件中对词法二元组信息的定义
    将原来的内部联合体m_data数据重新定义在TupleNode结点外部, 换为Data联合结构体表示词法信息的数据域
    将TupleNode中数据域与指针域分开, 将m_kind和m_data两个数据域合并为一个TupleData的数据域用来保存词法结点的信息
#
#
#
[代码修改信息]0.1.7
@@  在词法分析的基础上添加了预处理器的必要声明以及头文件信息
#
#
#
[代码修改信息]0.1.8
@@  将部分在Lexical.c文件中声明的PRIVATE函数移动到Buffer.h中,
    这类函数主要是跳过缓冲区中的部分特殊字符
    DisControl( ) -=> DisBufControl()
    DisSpace()   -=>    DisBugSpace()
@@  增加了词法分析器对词法信息[文件名, 行号]的定位
    在lexical中添加了函数LexProLine去识别line文件以及行信息的处理函数
@@  暂时可能除去有两个信息需要考虑
    一：  行信息Coord需要添加在TupleData声明中,　还是添加在TupleNode中
    二：  是在参数传递过程中传递一个额外的Coord变量, 还是将二元组词法表修改为循环链表
#
#
#
[代码修改信息]0.1.9
@@  增加了对预处理器遗留的#行号进行处理的函数,
    添加了词法分析对词法信息行号的识别和处理
    新增函数一：对#预处理信息进行处理, 识别出来当前词法信息所属的文件名和行号
    Coord* LexProCoord(DouBuffer *douBuffer, CToolsFILE ifp, Coord *coord)
    新增函数二：在处理控制字符时, 每遇见一个行号, 就将行号记录器增加1行
    void LexCntrlCoord(DouBuffer *douBuffer, CToolsFILE ifp, Coord *coord)
#
#
#
[代码修改信息]0.2.0
@@  完善了词法信息位置信息, 包括词法信息所属文件, 以及所在行记录以及处理
    存储结构为Coord, 定义位于Error.h文件中, 隶属于BinaryTuple.h文件TupleNode结构体中
@@  在Lexical接口中函数均添加了Coord参数以支持位置定位的处理,
    在BinaryTuple的接口中添加了为TupleNode* pNode词法结点信息赋值的必要操作

@@  未完成的操作以及BUG
    部分词法信息定位信息输出有误, 出现系统不确定地址的系统随机值 -=> 解决原因莫名其妙
    在某些情况下将#line表示后面的文件表示识别成了字符串    -=> 在Lexical.c的LexProCoord函数中最后尅有将双缓冲区开始指针和向前指针对齐
    在销毁词法二元组链表的时候, Coord节点信息没有被销毁, 造成了内存泄漏  -=> 在BinaryTuple.c的FreeNode函数中解决掉

@@  可能需要完成的操作
    可能需要将词法二元组链表更改为双向循环链表       -=>  未完成
#
#
#
[代码修改信息]0.2.1
@@  解决了0.2.0中未完成的操作以及BUG
    部分词法信息定位信息输出有误, 出现系统不确定地址的系统随机值 -=> 解决原因莫名其妙
    在某些情况下将#line表示后面的文件表示识别成了字符串    -=> 在Lexical.c的LexProCoord函数中最后尅有将双缓冲区开始指针和向前指针对齐
    在销毁词法二元组链表的时候, Coord节点信息没有被销毁, 造成了内存泄漏  -=> 在BinaryTuple.c的FreeNode函数中解决掉
#
#
#
[代码修改信息]0.2.2
@@  将词法分析的主程序封装为一个MainOfLexical函数
#
#
#
[代码修改信息]0.2.3
@@  增加了对预处理文件ProFile和源文件SourFile的词法分析
@@  将对分界符号的词法分解的函数LexSeparator针对ProFile预处理文件和SourFile源文件
    ①   LexSourSeparator  -=>   对源文件的分界符号进行分解
    ②   LexProSeparator   -=>   对预处理文件的分界符号进行分解
@@  将对运算符号的词法分解的函数LexSeparator针对ProFile预处理文件和SourFile源文件
    ①   LexSourOeperator  -=>   对源文件的运算符号进行分解
    ②   LexProOparator   -=>    对预处理文件的运算符号进行分解
@@  将词法分析的主要函数BufferLexical分解成预处理文件和SourFile源文件两个处理的函数
    ①   BufLexSourFile  -=>   对源文件的分界符号进行分解
    ②   BufLexProFile   -=>   对预处理文件的分界符号进行分解

@@  发现的问题, 对行号的识别存在一些偏差     -=> 已修复  原因InitCoord初始化时行号初始化为0, 应该初始化为0
#
#
#
[代码修改信息]0.2.3
@@  增加了对数字常量的识别
    和GCC采用类似的方式 正负符号 和 数据被当作不同的词法信息来进行处理
    处理的函数 lexical.c中LexConstant( )
#
#
#
[代码修改信息]0.2.4
@@  解决了文件打开封装函数在多文件打开过程中可能出现的BUG
    在打开多个文件过程中, 如果中间那某个文件打开失败, 应该把所有前面已经打开的文件全部关闭
    将原来的存在BUG的函数设定为 CToolsOpen( );
    更新后的函数设定为：CTooldFineOpen( );
#
#
#
[代码修改信息]0.2.5
@@  优化了双缓冲区的实现信息
    更改了InitBuffer( )函数的实现, 为双缓冲区开辟空间并返回指向缓冲区的指针
#
#
#
[代码修改信息]0.2.6
@@  优化了双缓冲区的实现信息
    更改了InitBuffer( )函数的实现, 为双缓冲区开辟空间并返回指向缓冲区的指针
#
#
#
[代码修改信息]0.2.7
@@  增加并且完善了词法分析器的错误显示功能, 同时修复了几个可能出现的BUG
#
#
#
[代码修改信息]0.2.8
@@  修改了词法分析器中的BUG
#
#
#[代码修改信息]0.2.9
@@  重大更新信息, 将CTools模块化, 各模块进行重新划分
    重新组合后的文件体系为
AderCTools
    ┏
    ┗Config..[CTools配置文件]
        ┏
        ┠Config.h       gcc编译器的配置文件, 用于构建CTools项目时进行编译器全局配置
        ┠
    ┏━┷            
    ┠
    ┗Global..[CTools全局接口]   
        ┏
        ┠CTools.c       CTools主接口程序, Main函数入口
        ┠CTools.h       CTools主接口程序, 提供CTools基本头文件信息
        ┠CTools.rc      CTools主界面文件配置文件
        ┠CTools.ico CTools界面文件
        ┠
    ┏━┷ 
    ┠
    ┗Lexical..[CTools词法分析器]     
        ┏
        ┠BinaryTuple.c      CTools词法二元组的函数接口实现
        ┠BinaryTuple.c      CTools词法二元组的定义以及函数声明
        ┠Lexical.c          CTools词法分析器的函数接口实现
        ┠Lexical.h          CTools词法分析器的函数接口声明
        ┠Lexical.rc     CTools词法分析器的界面配置文件
        ┠Lexical.ico        CTools词法分析器的界面文件
        ┠
    ┏━┷ 
    ┠
    ┗Parser..[CTools语法分析器]
        ┏
        ┠AnalyStack.c           CTools语法分析器的分析栈函数接口实现
        ┠AnalyStack.h           CTools语法分析器的分析栈定义以及函数声明
        ┠Grammar.c              CTools语法分析器的文法描述
        ┠Grammer.h              CTools语法分析器的文法描述
        ┠Parser.c               CTools语法分析器的主程序函数实现
        ┠Parser.h               CTools语法分析器的主程序函数声明 
        ┠Lexical.ico            CTools语法分析器的界面文件
        ┠StateStack.c           CTools语法分析器的状态栈函数接口实现
        ┠StateStack.h           CTools语法分析器的状态栈定义以及函数声明
        ┠SynAnaTable.c          CTools语法分析器的SLALR(1)语法分析表的实现    
        ┠SynAnaTable.h          CTools语法分析器的SLALR(1)语法分析表的声明
        ┠SyntacticParser.rc CTools语法分析器的界面配置文件
        ┠
    ┏━┷
    ┠
    ┗Preprocessor..[CTools预处理器]
        ┏
        ┠Preprocessor.c     CTools预处理器的主函数函数接口实现
        ┠Preprocessor.h     CTools预处理器的主函数函数接口声明
        ┠Preprocessor.ico       CTools预处理器的界面文件
        ┠Preprocessor.rc        CTools预处理器的主界面配置文件
        ┠
    ┏━┷
    ┠
    ┗Table..[CTools全局符号表]
        ┏
        ┠LiteralTable.c     CTools常量表函数接口实现
        ┠LiteralTable.h     CTools常量表定义以及函数接口声明
        ┠SymbolTable.c          CTools常量表函数接口实现
        ┠SymbolTable.h          CTools常量表定义以及函数接口声明
        ┠
    ┏━┷
    ┠
    ┗
#[代码修改信息]0.3.0
@@  在Error.h的词法位置标识结构体Coord添加
    当前词法信息开始位置在文件中的偏移m_fileBenOffset[:int]
    当前词法信息开始位置在文件中的偏移m_filEndOffset[:int]
    这样实现的话可以方便的选择插桩是在语句前面插桩, 还是后面插桩
@@  实现方案
    将一下语句进行配对
    CheckLexemeToForward(douBuffer) <===>   CheckBegOffsetToEndOffset(coord)
    douBuffer->m_lexeme <===>   coord->m_fileBegOffset
    douBuffer->m_forward    <===>   coord->m_fileEndOffset


#[代码修改信息]0.3.1
@@  修改了语法处理器的部分实现。
    将分析栈的数据类型Analy 定义为TupleNode*
    并修改了部分编译错误信息

    
#[代码修改信息]0.3.2
@@  修改了词法分析二元组的实现，
    将Coord数据类型添加在TupleData数据类型中
    // 未修改前的词法数据类型/////////////////////////////////////////////////////////////////////////
    //      typedef struct TupleData                                                                //
    //      {                                                                                       //  
    //          Kind    m_kind;       // 词法信息的种别码                                           //  
    //          Data    m_data;        // 词法信息的数据域                                          //
    //      }TupleData;                                                                             //
    //  修改前存放C语言词法信息的二元组结点                                                          //
    //      typedef struct TupleNode                                                                //
    //      {                                                                                       //
    //          TupleData           m_tuple;              // 词法二元组信息                            //  
    //          Coord               m_coord;                  // 词法二元组的行标识                  //
    //          struct TupleNode    *m_next;      // 词法信息中指向下一个结点的指针域               //
    //      }TupleNode;                                                                             //
    //////////////////////////////////////////////////////////////////////////////////////////////////
    
    // 修改后的词法数据类型///////////////////////////////////////////////////////////////////////////
    //      typedef struct TupleData                                                                //
    //      {                                                                                       //
    //          Kind    m_kind;       // 词法信息的种别码                                           //
    //          Data    m_data;        // 词法信息的数据域                                          //
    //          Coord   m_coord;      // 词法二元组的行标识                                          //
    //      }TupleData;                                                                             //
    // 修改前存放C语言词法信息的二元组结点                                                           //
    //      typedef struct TupleNode                                                                //
    //      {                                                                                       //
    //          TupleData           m_tuple;              // 词法二元组信息                            //
    //          Coord               m_coord;              // 词法二元组的行标识                      //
    //          struct TupleNode    *m_next;      // 词法信息中指向下一个结点的指针域                   //
    //      }TupleNode;                                                                             //
    //////////////////////////////////////////////////////////////////////////////////////////////////


#[代码修改信息]0.3.3
    修改了程序中的一些排版问题


#[代码修改信息]0.3.4
    重大更新
@@  重新休息Kind.h->    enum Kind的定义
    为关键字，运算符以及分界符添加了KIND定义信息方便语法分析阶段的处理
@@  修改了Kind的定义信息, 原来Tuple结构体中
    当结点信息是keyWord，operate，sparator时，m_kind标识了其种类[KEYWORD, OPERATE, SEPRARTOR]，m_kindCode标识了其的位置
    这样依据m_kind确定其种类，再根据m_kindCode去确定当前语法信息
    修改后的定义，m_kind标识为修改后的定义，不同的类型分别对应一个种别编码，而m_keyCode则标识了其大致种类
    这样修改的好处是，可以根据m_kind唯一确定任何一个语法符号的信息，


#[代码修改信息]0.3.5  2013/8/7-9:26
@@  将C语言LALR（1）分析表的ACTION表和GOTO表填入../Parser/SynAnaTable.c中
    更改源文件的目录结构, 将源../Tools/kind.h       -=> ../Lexical/TokenKind.h



#[代码修改信息]0.3.6  2013/8/11-10:55
@@  完善了语法分析表的部分信息, 包括LALR(1)语法分析表，以及Grammar文法信息



#[代码修改信息]0.3.7  2013/8/11-10:55
@@  修改了语法树的结构体定义
    //////////////////////////////////////////////////////////////////////////////////////////////////
    //  typedef union SynAnaTreeInfo                                                                //          
    //  {                                                                                           //      
    //      //TokenKind               m_tokenKind;                                                  //
    //      TupleNode*              m_tupleNode;        // 终结符结点指向的                         //
    //      SynAnaKind              m_synaAna;          // 当前结点信息是语法变量                      //
    //  }SynAnaTreeInfo;                                                                            //
    //  typedef struct SynAnaTreeData                                                               //
    //  {                                                                                           //
    //      SynAnaTreeKind          m_kind;                 // 标识当前树结点的种类                   //
    //      SynAnaTreeInfo          m_data;                 // 语法树结点的数据域信息                  //
    //  }SynAnaTreeData;                                                                            //
    //  typedef struct SynAnaTreeNode                                                               //
    //  {                                                                                           //
    //      SynAnaTreeData           m_synAna;           // 语法分析树结点数据域信息                    //
    //      struct SynAbaTreeNode*  m_parent;           // 指向父亲结点的指针域                       //
    //      struct SynAnaTreeNode*  m_firstChild;       // 指向孩子结点的指针域                       //
    //      struct SynAnaTreeNode*  m_rightBrother;     // 指向右边第一个兄弟                        //
    //  }SynAnaTreeNode;                                                                            //
    //////////////////////////////////////////////////////////////////////////////////////////////////

#[代码修改信息]0.3.8  2013/8/16-13:10
@@  修改了Parer/Parser.c中Parse的函数实现
    修改了部分bug
@@  发现重大BUG， 程序采用的源程序LALR(1)语法分析表有问题


#[代码修改信息]0.3.9  2013/8/18-16:25
@@  修改了语法栈的结点信息
@@  发现了重大BUG, 头文件的包含存在错误.
    解决问题, 重新更改头文件结果
    语法栈和语法树的结点定义互相包含
    应该将两个结点定义的头文件合并

#[代码修改信息]0.4.0 2013/8/18-16:28
@@  重大更新
    重新更改了语法栈和语法树的结点定义, 将定义信息以及函数声明信息合并到一个有Syntax.h头文件里面
    更改语法栈名称AnalyStack   -=> SyntaxStack
    更改语法树名称SynAnaTree   -=> SyntaxTree
AderCTools
    ┏
    ┗Config..[CTools配置文件]
        ┏
        ┠Config.h       gcc编译器的配置文件, 用于构建CTools项目时进行编译器全局配置
        ┠
    ┏━┷            
    ┠
    ┗Global..[CTools全局接口]   
        ┏
        ┠CTools.c               CTools主接口程序, Main函数入口
        ┠CTools.h           CTools主接口程序, 提供CTools基本头文件信息
        ┠CTools.rc              CTools主界面文件配置文件
        ┠CTools.ico             CTools界面文件
        ┠
    ┏━┷ 
    ┠
    ┗Lexical..[CTools词法分析器]     
        ┏
        ┠BinaryTuple.c          CTools词法二元组的函数接口实现
        ┠BinaryTuple.h          CTools词法二元组的定义以及函数声明
        ┠Lexical.c              CTools词法分析器的函数接口实现
        ┠Lexical.h              CTools词法分析器的函数接口声明
        ┠Lexical.ico            CTools词法分析器的界面文件
        ┠Lexical.rc             CTools词法分析器的界面配置文件
        ┠TokenKind.h            CTools词法分析器词法类型的实现
        ┠
    ┏━┷ 
    ┠
    ┗Parser..[CTools语法分析器]
        ┏
        ┠Grammar.c              CTools语法分析器的文法描述
        ┠Grammer.h              CTools语法分析器的文法描述
        ┠Parser.c               CTools语法分析器的主程序函数实现
        ┠Parser.h               CTools语法分析器的主程序函数声明 
        ┠Parser.ico             CTools语法分析器的界面文件
        ┠Parser.rc              CTools语法分析器的界面配置文件
        ┠StateStack.c           CTools语法分析器的状态栈函数接口实现
        ┠StateStack.h           CTools语法分析器的状态栈定义以及函数声明
        ┠Syntax.h               CTools语法分析器语法分析栈和语法分析树的定义以及函数声明
        ┠SyntaxKind.h           CTools语法类型枚举定义的信息
        ┠SyntaxStack.c          CTools语法分析器的分析栈函数接口实现
        ┠SyntaxTable.c          CTools语法分析器的LALR(1)语法分析表的实现 
        ┠SyntaxTable.h          CTools语法分析器的LALR(1)语法分析表的定义信息以及函数声明 
        ┠SyntaxTree.c           CTools语法分析器的语法树的实现  
    ┏━┷
    ┠
    ┗Preprocessor..[CTools预处理器]
        ┏
        ┠Preprocessor.c         CTools预处理器的主函数函数接口实现
        ┠Preprocessor.h         CTools预处理器的主函数函数接口声明
        ┠Preprocessor.ico       CTools预处理器的界面文件
        ┠Preprocessor.rc        CTools预处理器的主界面配置文件
        ┠
    ┏━┷
    ┠
    ┗Table..[CTools全局符号表]
        ┏
        ┠LiteralTable.c         CTools常量表函数接口实现
        ┠LiteralTable.h         CTools常量表定义以及函数接口声明
        ┠SymbolTable.c          CTools常量表函数接口实现
        ┠SymbolTable.h          CTools常量表定义以及函数接口声明
        ┠
    ┏━┷
    ┠
    ┗


#[代码修改信息]0.4.2 2013/8/21-17:22
@@  重大更新
    重新修改了Lexical词法分析程序, 将源文件跟预编译文件合并处理, 不再分开处理
    将分来处理的函数进行废弃

#[代码修改信息]0.4.3 2013/8/24-20:18
@@  将0.4.2中废弃的函数接口删除，
@@  消除了一个词法分析阶段文件处理永不终止的BUG
@@  将当前字符是不是EOF的处理，移动到了跳过控制字符的函数中
    简化了BufferLexical函数的实现

#[代码修改信息]0.4.4 2013/8/28-14：12
@@  在tokenkind中插入了多重指针的枚举定义，
    在allOperate中插入了"**"，“***”的定义信息，
    发现了多重指针后，直接获取信息，使CTools支持多重指针


#[代码修改信息]0.4.5 2013/10/21-17:19
@@  纠正C语法分析表中的归约编号错误的重大错误
    更改HELP文件夹中action表文件action.lalr中所有归约信息归约产生式编号

#[代码修改信息]0.4.6 2013/10/27-19:29
@@  纠正C语法分分析表文件中的定义信息


#[代码修改信息]0.4.7 2013/10/28-21:38
@@  纠正了语法分析表中残留的部分错误信息

#[代码修改信息]0.4.8 2013/8/21-17:22
@@  纠正了词法分析阶段的部分BUG
    将常量信息进行处理，
    将常量区分为一下几类
    整型常量int_const       由IsConst函数判断, LexConst函数处理
    浮点数常量float_const    由IsConst函数判断, LexConst函数处理
    字符常量charactor_const 遇见‘时自行判断，由LexCharactor函数处理
    字符串常量string_const   遇见“时自行判断，由LexString函数处理


    
#[代码修改信息]0.4.9 2013/10/30-8:26
@@  纠正了词法分析阶段的部分BUG
    将空格‘ ’和制表符‘\t’均当作C语言空白字符处理
    修改改了LexCntrlCoord函数的实现
    增加了Config.h中,IsSpace()宏函数的实现

#[代码修改信息]0.5.0 2013/10/30-14:11
@@  纠正了词法分析阶段的部分BUG,以及语法分析表的部分错误信息
    ①   TokenKind定义中枚举常量的顺序域Lexical.c中变量定义的顺序以及编号不一致
    ②   修改可上一版本中对字符常量和字符串常量识别过程中出现的部分BUG

    暂时功能实现：能够识别一些简单的C语言文法信息
    能够处理一些预处理后的C语言源文件
    BUG :   不支持对源文件的中预处理指令的语法识别
            但是提供了对预处理指令识别的接口    


重大信息：
    选择项目的终结状态

#[代码修改信息]0.5.12 2013/11/4 16:26
    重大更新
    此版本为纪念我最爱的人(王盼盼生日1991-5-12)
    修复了语法树子树与根的关联信息，
    测试语法树建立成功
    但是插入过程中root根其实没用处，
    分支版本0.5.12为去掉语法树根的实现方案
    分支版本0.5.13为添加root语法树根的实现方案
    但是为了使程序在出错后，能够正常清除语法树，我们在以后的版本中将使用0.5.12的实现方案



#[代码修改信息]0.5.2  2013/11/5 20:26
@@  修复了语法树的实现， 采用0.5.12去掉root根的实方案
    语法树显示正常
    修复了语法树中语法数结点个数显示不正确的BUG
    修复了语法树中序遍历和后序遍历不正确的BUG


#[代码修改信息]0.5.3  2013/11/7 11:16
    在语法树节点中每个域添加m_startCoord和m_endCoord域用于标识当前语法变量在源文件中起始和结束位置
    
    插桩有两种思路
    ①思路是：在语法分析时，边归约，然后根据每个产生式的不同类型执行不同的插桩动作
        优点: 易于实现，依据每个产生式的形式进行插桩，插桩比较全面
        缺点: 增加了语法分析的复杂程度, 
            如果我们不需要插桩，这样编译过程中就执行了一些无用的操作
            (这点好解决,可以插入预编译指令开启语法分析过程中的插桩)
    ②思路是: 在语法分析结束后, 依据语法树进行插桩
        优点: 较为通用， 可以简化思考的过程 
        缺点: 插桩的过程可能不全面, 
            (这点可以在后期考虑，采取某种策略增加其全面的覆盖率) 
        两种方式都很好扩展，都可以实现条件插桩，循环插桩，变量插桩
    下面的版本我们将优先采用第②种思路，
    但是部保证未来不会去实现第一种思路

    构建了一个简答的插桩测试文件，文件位于TEST/prop.c

#[代码修改信息]0.5.4  2013/11/7 11:16
@@  优化了语法分析器数据结构部分的实现
    重点修改了语法树、语法分析栈和语法队列的实现, 0.5.4以后其实现定义如下
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// /// 语法结点
    /// typedef struct SyntaxTreeNode
    /// {
    ///     // 语法结点数据域
    ///     SyntaxData           m_syntax;           // 语法分析树结点数据域信息
    ///
    ///     // 语法树指针数据域
    ///     struct SyntaxTreeNode*  m_parent;           // 指向父亲结点的指针域
    ///     struct SyntaxTreeNode*  m_firstChild;       // 指向孩子结点的指针域
    ///     struct SyntaxTreeNode*  m_rightBrother;     // 指向右边第一个兄弟
    ///     struct SyntaxTreeNode*  m_finalChild;       // 指向最后一个孩子结点的指针域
    ///     struct SyntaxTreeNode*  m_leftBrother;      // 指向左边第一个兄弟结点
    ///     
    ///     // 语法栈或者语法队列数据域
    ///     struct SyntaxTreeNode*  m_next;             // 指向下一个结点的数据域
    /// }SyntaxTreeNode, SyntaxStackNode, SyntaxQueueNode;
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    其中语法树指针数据域为当前结点作为语法树结点所使用的数据域.
    其中语法栈或者语法队列数据域为当前结点作为语法分析栈或者语法队列时所使用的数据域.


#[代码修改信息]0.5.5  2013/11/7 11:16
    修复了语法队列总是为空的BUG..



#[代码修改信息]0.5.6  2013/11/7 11:16
    增加了第10个产生式的插桩动作
    第10个产生式对应的C代码含义为:函数定义
    
    重大更新:
    重新修改了插桩器Prop的实现思路
    在归约的过程中建立一个插桩信息表, 
    插桩信息表中用线性链表实现， 每个结点用来表示一个插桩动作
    标识了待插桩的位置, 需要插入的桩格式串的形式
    完成后按照偏移的由小到大, 对源文件进行排序
    最后依据插桩信息表对源文件进行插桩

#[代码修改信息]0.5.7  2013/11/20 08:10:25
@@  实现了插桩信息表的构建
    完善了对大部分C语法产生式的插桩动作



#[代码修改信息]0.5.8  2013/11/20 11:40
@@  基本实现的90%C语句的插桩动作
    BUG:    ① 文件未关闭
        ② 添加插桩文件打开描述符后， 文件的行号需要被重新定向


#[代码修改信息]0.5.9  2013/11/21 10:11
@@  修复了在程序结束后， 插桩文件未关闭的BUG
    修改了文件打开描述插桩宏的信息的插入思路， 
    将串修改为一行，因此不同在重定向行号信息


#[代码修改信息]0.5.9  2013/11/21 10:11
@@  增加了对预编译指令的支持
    处理方式是，在词法分析阶段将数据过滤掉
    BUG: DisBufSpace( )中只增加了缓冲区向前指针的位置，但是未增加位置偏移结束偏移


#[代码修改信息]0.6.0 2013-11-25 10：26
@@  对程序进行了优化，
    ①   修改了缓冲区结构体的实现，将文件指针，以及文件位置偏移的封装在缓冲区结构体中，
        优化了词法分析阶段的程序参数传递


#[代码修改信息]0.6.1 2013-11-25 14:23
@@  修复了\n作为结束时，前一个标识串无法正确取出的BUG

#[代码修改信息]0.6.2 2013-11-25 17:18
@@  优化了Lexical和Bufffer的实现
    ①   将Lex全局变量的设置更改到TokenKind.c中
    ②   将所有对缓冲区指针的操作封装在Buffer.h和Buffer.c中
    ③   增加了对缓冲区的跳过空白，控制，普通注释信息的处理


#[代码修改信息]0.6.3 2013-11-26 17：22
@@  重新构建了LALR(1)语法分析表, 增加了对C99语法的支持
    发现BUG: 
    ①   不识别函数声明以及定义语句int main( );
    ②   不识别(a + b)类型的带括号运算式子
    ③   不识别bool类型的变量声明
    ③   不识别i++l类型的式子
    ④   不识别结构体


#[代码修改信息]0.6.4 2013-11-27 18:45
@@  修改了重构的C99语法分析表的部分BUG
    ①   修复了对函数定义式子的识别
        action 38   identifier      (0，58)修改了(1, 15)
    ②   修复了对(a + b)类型带括号运算式子的识别
        action  85  identifier 原来是169, 更改为150 。等价于原来的68 
    ③   修复了对i++类型式子的识别
        action 59  identifier 原来是114, 更改为185 。等价于原来的97
    ④   修复了对struct结构体定义式子的识别
        161 identifier      (0，58)修改了(1, 58)


#[代码修改信息]0.6.5 2013-11-28 10:27
@@  充实了对结构体的识别


#[代码修改信息]0.6.6 2013-11-28 11:30
@@  修复了重新更改语法分析表和C文法结构后造成的产生式插桩的部协调
    现在产生式编号135  === 原来产生式编号124
    现在产生式编号136  === 原来产生式编号125
    现在产生式编号137  === 原来产生式编号126
    现在产生式编号138  === 原来产生式编号127
    现在产生式编号138  === 原来产生式编号128
    现在产生式编号140  === 原来产生式编号129
    现在产生式编号141  === 原来产生式编号130
    现在产生式编号142  === 原来产生式编号131
    现在产生式编号143  === 原来产生式编号132
    现在产生式编号144  === 原来产生式编号133
    现在产生式编号145  === 原来产生式编号134
    现在产生式编号146  === 原来产生式编号135
    现在产生式编号147  === 原来产生式编号136
    现在产生式编号148  === 原来产生式编号137
    现在产生式编号149  === 原来产生式编号138
    现在产生式编号150  === 原来产生式编号139
    现在产生式编号151  === 原来产生式编号140
    现在产生式编号152  === 原来产生式编号141
    现在产生式编号127  === 原来产生式编号116
    现在产生式编号128  === 原来产生式编号117

@@  修改了基础Lexical词法分析阶段的BUG
    ①   DisBufSpace函数中，先增加向前指针，再增加行号，导致了行号显示不准确
    ②      LexOperator函数中，对/**/的处理不够准确AddBufLexeme(douBuffer);


#[代码修改信息]0.6.7 2013-11-28 11:30
    重新修改了LALR语法分析表的实现


#[代码修改信息]0.6.8 2013-11-28 11:30
    重新修改了LALR语法分析表的实现
    发现了一下几个问题

    下面的几个状态应该根据(1)按照不同的产生式归约，但是语法分析表中并不完全
    //在一下几个状态中增加了(1，117)
    114，144，169，180，304，22
    //一下几个状态中对identifier的处理是错误的, 但是修改却会导致其他文法无法识别的错误
    32  // 已经修改-=>识别不带返回值的函数定义
    38  // 识别函数定义式子
    37
    161 // 识别结构体
    160
    21  // inline main(){ }


#[代码修改信息]0.6.9 2013-12-2 10:06
    发现了缓冲区DouBuffer在缓冲区发现的BUG
    当文件足够大，需要多次填充缓冲区的时候，由于缓冲区实现中的BUG,可能导致取出来的串过长，或者长度为负数



#[代码修改信息]0.7.0 2013-12-3 08:21
    在actiontable对114和185状态的处理中增加了对114和185状态的处理



#[代码修改信息]0.7.1 ~ 0.7.5 2013-12-3 08:21
    修改了语法分析表中的信息是处理问题


#[代码修改信息]0.7.6 2013-12-3 08:21
    修改了对跳转语句的插桩
    eg :    goto lable 原本插桩后的语句为goto LINE(), label;
                       修改后插桩的语句LINE( ); goto label;


#[代码修改信息]0.7.7 2014-03-06 14:59
    修改了插桩探针的设计
    ① for循环语句原来在三个语句处均添加"探针"信息,
        现在只在第一条语句和最后一个语句处添加“探针”信息
    eg : for(int i = 0; i < 10; i++)
    old: for(LINE(stream), int i = 0; LINE(stream), i < 10; LINE(stream),i++)
    new: for(LINE(stream), int i = 0; i < 10; LINE(stream),i++)

    ②  修改了所有简单语句的"探针"策略
        原来的策略： 在语句的分号";"后面添加带";"的"探针"LINE(strmeam)
        会带来的缺陷: 可能导致只有一行语句的循环短路
        eg : for(int i = 0; i < 10; i++)
                printf("%d\n", i);
        原来插桩结束
            for(int i = 0; i < 10; i++)
                printf("%d\n", i); LINE(stream);
        插桩的结果其实成为这样的语句
            for(int i = 0； i　< 10; i++)
            {
                printf("%d\n", i);
            }
            LINE(stream);
        
        在语句的起始位置，添加一个带","的"探针"
            for(int i = 0; i < 10; i++)
                LINE(stream), printf("%d\n", i);
    ③ 但是软件仍然存在BUG， 在于：
    原来在跳转语句goto, return, break, continue的插桩策略可能导致循环短路甚至出现编译错误
    eg下面的源代码
    for(int i = 0; i < 10; i++)
        break;
    原来的插桩策略, 
    for(int i = 0； i < 10; i++)
        LINE(stream);break;
    应该转换插桩策略, 


        
#[代码修改信息]0.7.8 2015-02-11 14:59
    对于0.7.7版本修复的以及提出的部分BUG，
    其实都是针对那些不算非常合乎编程规范的代码的
    比如说我们的对于循环的插桩短路问题，
    其实都是因为for在编写的过程中, 未编写"{"，"}"造成的
    这点也提醒我们在编程过程中，养成一个良好的编程风格是多么重要

    对于这些问题，其实我们有三种思路去解决
    ①强制用户去使用一种合乎规范的编程风格，来简化我们的程序处理
        对于由用户编程不规范，所造成的一切问题，交给用户手动解决
    说明： 但是其实，我们并不能强制用户去做什么，
            往往用户因为疏忽或者编程能力有限，可能导致我们的程序出现BUG
            这些应该最好交给我们去处理
    ②设计一个前端的预处理器，将用户不符合编程规范的程序，调整成我们程序方便处理的程序代码
    ③在后面改变插桩策略。。。。。

    其中后面两种策略是需要我们去实现的
    
    对于第②种，我们将在后期编译器基本完善以后，去实现一些外围的辅助工具
    代码规范器是我们必须要做的，因为我们的编译工具集合，是一套工具接口，而不是一个简单的编译器

    下面我们给出第③中的解决方案
    遇见跳转语句，就在前面插入一个"{"同时在语句的最后加上一个"LINE(stream);}"格式的串

#[项目配置更新]2015-2-11 19:10
	将项目迁移至GitHub

        
#[代码修改信息]0.7.9 2014-02-12 18:15
    发下一处新的BUG，详细内容参见TEST/BUG/bug8.c

    // bug8
    // scanf() 和 printf 函数位于int a;定义后会出现崩溃
    //  下面的代码导致程序崩溃
    int main()
    {
	int a;
	scanf("%d", &a);
    }		
    //  下面的代码则运行正常
    int main()
    {
	scanf("%d", &a);
    }		